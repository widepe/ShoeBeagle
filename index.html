<!-- /pages/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="/images/favicon.svg">
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self';
                 script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com;
                 img-src * data: https:;
                 style-src 'self' 'unsafe-inline';
                 connect-src 'self' https://v3gjlrmpc76mymfc.public.blob.vercel-storage.com;
                 font-src 'self';
                 frame-src 'none';">
  <title>Shoe Beagle--The Running Shoe Deal Finder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- CSS split -->
  <link rel="stylesheet" href="/pages/index.css?v=87">

  <!--
    IMPORTANT:
    Set this at deploy time to avoid hardcoding the blob store base.
    Example value:
      https://v3gjlrmpc76mymfc.public.blob.vercel-storage.com
  -->
  <meta name="shoebeagle-blob-base" content="__BLOB_BASE_URL__">
</head>

<body>
  <div class="app">
    <img class="mobile-top-banner" src="/images/logo_heading.svg" alt="">

    <!-- TOP AREA: inputs left, logo right -->
    <div class="topbar">
      <div class="top-left">
        <form id="search-form" method="POST" autocomplete="off">

          <!-- SINGLE SEARCH ROW: unified input + menu + fetch -->
          <div class="row">
            <div class="input-wrapper">
              <img class="input-icon" src="/images/mg.svg" alt="" aria-hidden="true">
              <input id="q" type="text" placeholder="Search brand or model..." autocomplete="off"/>
              <button type="button" class="input-clear" aria-label="Clear search">&times;</button>
              <div id="qSuggestions" class="suggestions"></div>
            </div>

            <div class="button-wrapper">
              <button id="menuBtn"
                      type="button"
                      class="btn-eq"
                      aria-label="Links"
                      aria-expanded="false"
                      aria-controls="linksRibbon">
                <img src="/images/menu.svg" class="btn-icon" alt="Links">
              </button>
            </div>

            <div class="button-wrapper">
              <button id="fetchBtn" type="submit" class="btn-eq" aria-label="Fetch">
                <img src="/images/fetch.svg" class="btn-icon" alt="Fetch">
              </button>
            </div>
          </div>

        </form>
      </div>

      <!-- LOGO RIGHT -->
      <div class="top-right">
        <img
          src="/images/logo.svg"
          class="brand-logo"
          alt="Shoe Beagle Logo"
          id="logoLink"
        >
      </div>
    </div>

    <!-- Links ribbon (hidden by default; toggled by the button above) -->
    <div id="linksRibbon" class="links-ribbon" style="display:none;">
      <div class="links-ribbon-inner">

        <!-- LEFT: Set Alert -->
        <div class="links-ribbon-left">
          <a class="links-ribbon-link" href="#" data-open-alert>Set Alert</a>
        </div>

        <!-- CENTER: Filter + Sort dropdowns -->
        <div class="links-ribbon-center">
          <div class="ribbon-controls" role="group" aria-label="Filter and sort">

            <label class="ribbon-label" for="ribbonGender">Gender</label>
            <select id="ribbonGender" class="ribbon-select" aria-label="Filter by gender">
              <option value="" selected>Off</option>
              <option value="mens">Mens</option>
              <option value="womens">Womens</option>
            </select>

            <label class="ribbon-label" for="ribbonType">Shoe Type</label>
            <select id="ribbonType" class="ribbon-select" aria-label="Filter by shoe type">
              <option value="" selected>Off</option>
              <option value="road">Road</option>
              <option value="trail">Trail</option>
              <option value="track">Track</option>
            </select>

            <label class="ribbon-label" for="ribbonSort">Sort</label>
            <select id="ribbonSort" class="ribbon-select" aria-label="Sort results">
              <option value="" selected>Off</option>
              <option value="price-asc">Price: Lo → Hi</option>
              <option value="price-desc">Price: Hi → Lo</option>
              <option value="pct-asc">% Off: Lo → Hi</option>
              <option value="pct-desc">% Off: Hi → Lo</option>
              <option value="save-asc">Savings: Lo → Hi</option>
              <option value="save-desc">Savings: Hi → Lo</option>
            </select>

          </div>
        </div>

        <!-- RIGHT: Favorites + close -->
        <div class="links-ribbon-right">
          <a class="links-ribbon-link is-disabled" href="#" aria-disabled="true" tabindex="0">Favorites</a>
          <button type="button" class="chip-close" aria-label="Close links">×</button>
        </div>

      </div>
    </div>

    <div id="mainContent">
      <div class="status-message" id="statusMessage">
        Marty’s Daily Deals
      </div>

      <div class="daily-deals" id="dailyDeals">
        <div class="shoe-grid" id="dailyDealsGrid"></div>
      </div>

      <div class="shoe-grid" id="results"></div>

      <div class="load-more-wrap" id="loadMoreWrap" style="display:none;">
        <button id="loadMoreBtn" class="load-more-btn" type="button">Load more</button>
      </div>

      <div class="pager">
        <button id="prevPage" class="pager-btn" aria-label="Previous page">◀</button>
        <div id="pageLabel" class="page-label">1 / 1</div>
        <button id="nextPage" class="pager-btn" aria-label="Next page">▶</button>
      </div>

      <p class="disclaimer">
        Shoe Beagle may earn commissions through our affiliate program at no cost to you.
        We do not sell products directly and are not responsible for changes in price, availability,
        or shipping terms on retailer sites.
      </p>
    </div>

    <div class="footer">
      <div class="footer-links">
        <a href="/pages/about.html">About</a> |
        <a href="/pages/contact.html">Contact</a> |
        <a href="/pages/privacy.html">Privacy</a> |
        <a href="/pages/terms.html">Terms</a>
      </div>

      <div class="footer-copy">
        © <span id="footerYear"></span> Shoe Beagle. All rights reserved.
      </div>
    </div>

    <button class="to-top" id="toTopBtn" type="button" aria-label="Back to top">↑</button>
  </div>

  <!-- Load brand/models once (root) -->
  <!-- NOTE: main page no longer uses brandModels.js for suggestions.
       Modal still uses it (by design). -->
  <script src="/brandModels.js"></script>

  <!-- ===== Main Page Script ===== -->
  <script>
  (() => {
    const form = document.getElementById("search-form");

    const statusMessageEl = document.getElementById("statusMessage");
    const resultsEl = document.getElementById("results");
    const dailyDeals = document.getElementById("dailyDeals");
    const dailyDealsGrid = document.getElementById("dailyDealsGrid");
    const fetchBtn = document.getElementById("fetchBtn");

    // Unified input + suggestions
    const qInput = document.getElementById("q");
    const qSuggestions = document.getElementById("qSuggestions");

    const logoLink = document.getElementById("logoLink");
    const footerYear = document.getElementById("footerYear");
    const appEl = document.querySelector(".app");

    // Links toggle button + ribbon
    const menuBtn = document.getElementById("menuBtn");
    const linksRibbon = document.getElementById("linksRibbon");
    const linksRibbonClose = linksRibbon?.querySelector(".chip-close");

    // Ribbon dropdowns
    const ribbonGender = document.getElementById("ribbonGender");
    const ribbonType   = document.getElementById("ribbonType");
    const ribbonSort   = document.getElementById("ribbonSort");

    const PAGE_SIZE = 12;
    let pageIndex = 0;

    const prevPageBtn = document.getElementById("prevPage");
    const nextPageBtn = document.getElementById("nextPage");
    const pageLabelEl = document.getElementById("pageLabel");

    // Load more elements
    const loadMoreWrap = document.getElementById("loadMoreWrap");
    const loadMoreBtn = document.getElementById("loadMoreBtn");
    const toTopBtn = document.getElementById("toTopBtn");

    function isMobilePortrait(){
      return window.matchMedia("(max-width: 560px) and (orientation: portrait)").matches;
    }

    function runPagerTransitionThen(fn){
      if (isMobilePortrait()) { fn(); return; }
      resultsEl.classList.add("is-switching");
      setTimeout(() => {
        fn();
        requestAnimationFrame(() => {
          resultsEl.classList.remove("is-switching");
        });
      }, 160);
    }

    // Current search state (still brand+model under the hood)
    let currentSearch = { brand: "", model: "" };
    let lastSearchResults = [];
    let lastDailyDeals = [];

    // Unified state (ribbon dropdowns update these)
    let selectedGender = "";      // "" | "mens" | "womens"
    let selectedShoeType = "";    // "" | "road" | "trail" | "track"
    let currentSort = "";         // "" | "price-asc" | "price-desc" | "pct-asc" | "pct-desc" | "save-asc" | "save-desc"

    if (footerYear) footerYear.textContent = new Date().getFullYear();
    if (logoLink) logoLink.addEventListener("click", () => location.reload());

    // --- Links ribbon toggle ---
    function isRibbonOpen(){
      return !!(linksRibbon && linksRibbon.style.display !== "none");
    }
    function openRibbon(){
      if (!linksRibbon) return;
      linksRibbon.style.display = "block";
      if (menuBtn) menuBtn.setAttribute("aria-expanded", "true");
    }
    function closeRibbon(){
      if (!linksRibbon) return;
      linksRibbon.style.display = "none";
      if (menuBtn) menuBtn.setAttribute("aria-expanded", "false");
    }
    function toggleRibbon(){
      if (!linksRibbon) return;
      if (isRibbonOpen()) closeRibbon();
      else openRibbon();
    }

    if (menuBtn) {
      menuBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        toggleRibbon();
      });
    }

    if (linksRibbonClose) {
      linksRibbonClose.addEventListener("click", (e) => {
        e.preventDefault();
        closeRibbon();
      });
    }

    // --- Helpers ---
    function normalizeStr(s) { return String(s || "").trim().toLowerCase(); }
    function norm(s) { return String(s || "").trim().toLowerCase(); }

    function sanitizeInput(str) {
      return String(str || "")
        .replace(/[<>'"]/g, '')
        .replace(/script/gi, '')
        .replace(/javascript:/gi, '')
        .replace(/on\w+=/gi, '')
        .trim()
        .slice(0, 100);
    }

    function squashStr(s) { return String(s || "").toLowerCase().replace(/[^a-z0-9]/g, ""); }

    function updateFetchReady() {
      const hasAny = !!(qInput && qInput.value.trim());
      if (fetchBtn) fetchBtn.disabled = !hasAny;
    }
    updateFetchReady();

    // Clear button (single)
    const clearBtn = document.querySelector('.input-clear');
    if (clearBtn) {
      clearBtn.addEventListener('click', (e) => {
        e.preventDefault();
        if (qInput) {
          qInput.value = '';
          qInput.focus();
          closeSuggestions();
          updateFetchReady();
        }
      });
    }

    function isValidRetailerUrl(url) {
      if (!url || url === '#') return false;
      try {
        const u = new URL(url);
        return u.protocol === "https:" || u.protocol === "http:";
      } catch {
        return false;
      }
    }

    // --- Blob base ---
    function getBlobBase() {
      const meta = document.querySelector('meta[name="shoebeagle-blob-base"]');
      const fromMeta = meta ? String(meta.getAttribute("content") || "").trim() : "";
      const looksLikePlaceholder = fromMeta.includes("__BLOB_BASE_URL__");
      if (fromMeta && !looksLikePlaceholder) return fromMeta.replace(/\/+$/, "");
      return "https://v3gjlrmpc76mymfc.public.blob.vercel-storage.com";
    }

    function blobUrl(path) {
      const base = getBlobBase();
      const cleanPath = String(path || "").replace(/^\/+/, "");
      return base.replace(/\/+$/, "") + "/" + cleanPath;
    }

    // ===============================
    // Suggestions index = deals.json ONLY
    // ===============================
    const dealsSuggest = {
      ready: false,
      brandNormToDisplay: new Map(),      // normBrand -> "Nike"
      brandToModels: new Map(),           // "Nike" -> Map(normModel -> "Pegasus 42")
      allModelsNormToDisplay: new Map(),  // normModel -> "Pegasus 42"
      modelNormToBrandDisplay: new Map(), // normModel -> "Nike" (first brand wins)
      brands: [],
      allModels: [],
    };

    async function loadDealsSuggestionIndex(){
      try {
        const url = blobUrl("deals.json");
        const res = await fetch(`${url}${url.includes("?") ? "&" : "?"}cb=${Date.now()}`, { cache: "no-store" });
        if (!res.ok) throw new Error(`deals.json fetch failed: ${res.status}`);

        const data = await res.json();
        const deals = Array.isArray(data?.deals) ? data.deals : [];

        dealsSuggest.brandNormToDisplay.clear();
        dealsSuggest.brandToModels.clear();
        dealsSuggest.allModelsNormToDisplay.clear();
        dealsSuggest.modelNormToBrandDisplay.clear();

        for (const d of deals) {
          const brandRaw = String(d?.brand || "").trim();
          const modelRaw = String(d?.model || "").trim();

          if (brandRaw) {
            const bNorm = normalizeStr(brandRaw);

            if (!dealsSuggest.brandNormToDisplay.has(bNorm)) {
              dealsSuggest.brandNormToDisplay.set(bNorm, brandRaw);
            }

            const bDisplay = dealsSuggest.brandNormToDisplay.get(bNorm);

            if (!dealsSuggest.brandToModels.has(bDisplay)) {
              dealsSuggest.brandToModels.set(bDisplay, new Map());
            }

            if (modelRaw) {
              const mNorm = normalizeStr(modelRaw);
              const modelMap = dealsSuggest.brandToModels.get(bDisplay);
              if (!modelMap.has(mNorm)) modelMap.set(mNorm, modelRaw);

              if (!dealsSuggest.modelNormToBrandDisplay.has(mNorm)) {
                dealsSuggest.modelNormToBrandDisplay.set(mNorm, bDisplay);
              }
            }
          }

          if (modelRaw) {
            const mNorm = normalizeStr(modelRaw);
            if (!dealsSuggest.allModelsNormToDisplay.has(mNorm)) {
              dealsSuggest.allModelsNormToDisplay.set(mNorm, modelRaw);
            }
          }
        }

        dealsSuggest.brands = Array.from(dealsSuggest.brandNormToDisplay.values()).sort((a,b) => a.localeCompare(b));
        dealsSuggest.allModels = Array.from(dealsSuggest.allModelsNormToDisplay.values()).sort((a,b) => a.localeCompare(b));
        dealsSuggest.ready = true;
      } catch (e) {
        console.error("[suggestions] Failed to build deals.json suggestion index:", e?.message || String(e));
        dealsSuggest.ready = false;
        dealsSuggest.brands = [];
        dealsSuggest.allModels = [];
      }
    }

    function inferDefinitiveBrandFromPartialModel(modelTyped){
      if (!dealsSuggest.ready) return "";
      const q = squashStr(modelTyped);
      if (!q || q.length < 3) return "";

      const brandsFound = new Set();

      for (const modelDisplay of dealsSuggest.allModels) {
        const mSquash = squashStr(modelDisplay);
        if (!mSquash.includes(q)) continue;

        const b = dealsSuggest.modelNormToBrandDisplay.get(normalizeStr(modelDisplay)) || "";
        if (b) brandsFound.add(b);

        if (brandsFound.size > 1) return ""; // ambiguous
      }

      return brandsFound.size === 1 ? Array.from(brandsFound)[0] : "";
    }

    // "closest brand" based ONLY on deals.json brands (used for parsing brand prefix)
    function levenshtein(a, b) {
      a = String(a || "");
      b = String(b || "");
      const m = a.length, n = b.length;
      if (!m) return n;
      if (!n) return m;

      const dp = new Array(n + 1);
      for (let j = 0; j <= n; j++) dp[j] = j;

      for (let i = 1; i <= m; i++) {
        let prev = dp[0];
        dp[0] = i;
        for (let j = 1; j <= n; j++) {
          const temp = dp[j];
          const cost = a[i - 1] === b[j - 1] ? 0 : 1;
          dp[j] = Math.min(dp[j] + 1, dp[j - 1] + 1, prev + cost);
          prev = temp;
        }
      }
      return dp[n];
    }

    function resolveClosestBrand(input) {
      const raw = String(input || "").trim();
      if (!raw) return "";
      if (!dealsSuggest.ready || !dealsSuggest.brands.length) return raw;

      const exact = dealsSuggest.brands.find(b => normalizeStr(b) === normalizeStr(raw));
      if (exact) return exact;

      const q = squashStr(raw);
      if (!q) return raw;

      let best = null;
      let bestDist = Infinity;

      for (const b of dealsSuggest.brands) {
        const bs = squashStr(b);
        const d = levenshtein(q, bs);
        if (d < bestDist) {
          bestDist = d;
          best = b;
        }
      }

      const len = q.length;
      const threshold = len <= 4 ? 1 : (len <= 7 ? 2 : 3);
      return (best != null && bestDist <= threshold) ? best : raw;
    }

    function scoreSuggestion(candidate, query) {
      const c = String(candidate || "");
      const cl = c.toLowerCase();
      const q = String(query || "").trim().toLowerCase();
      if (!q) return 0;

      const cSquash = squashStr(c);
      const qSquash = squashStr(q);

      let score = 0;
      if (cl.startsWith(q)) score += 120;
      if (cl.includes(q)) score += 80;
      if (qSquash.length >= 3 && cSquash.includes(qSquash)) score += 110;

      const qParts = q.split(/\s+/).filter(Boolean);
      if (qParts.length >= 2) {
        const cParts = cl.split(/\s+/);
        let tokenHits = 0;
        for (const qp of qParts) {
          if (cParts.some(cp => cp.startsWith(qp))) tokenHits++;
        }
        score += tokenHits * 25;
      }

      score -= Math.min(c.length, 30) * 0.25;
      return score;
    }

    function filterSuggestions(list, typed, limit = 10) {
      const q = String(typed || "").trim();
      if (!q) return [];

      const qLower = q.toLowerCase();
      const starts = list.filter(v => String(v).toLowerCase().startsWith(qLower));
      if (starts.length) {
        const ranked = starts
          .map(v => ({ v, s: scoreSuggestion(v, q) }))
          .sort((a, b) => b.s - a.s)
          .slice(0, limit)
          .map(x => x.v);
        return Array.from(new Set(ranked));
      }

      const scored = list
        .map(v => ({ v, s: scoreSuggestion(v, q) }))
        .filter(x => x.s > 0)
        .sort((a, b) => b.s - a.s)
        .slice(0, limit)
        .map(x => x.v);

      return Array.from(new Set(scored));
    }

    // ---------- Unified suggestion behavior ----------
    // If user starts with a brand prefix (unique), show "Brand Model" suggestions.
    // Otherwise, show model-only suggestions.
    function detectBrandPrefix(typed){
      if (!dealsSuggest.ready) return { brand: "", rest: typed };

      const raw = String(typed || "").trim();
      if (!raw) return { brand: "", rest: "" };

      // Consider first token as brand prefix (nike, asics, saucony...)
      const parts = raw.split(/\s+/).filter(Boolean);
      if (!parts.length) return { brand: "", rest: raw };

      const first = parts[0];
      if (first.length < 2) return { brand: "", rest: raw };

      const firstNorm = squashStr(first);
      const matches = dealsSuggest.brands.filter(b => squashStr(b).startsWith(firstNorm));

      if (matches.length === 1) {
        const brand = matches[0];
        const rest = raw.slice(parts[0].length).trim(); // remainder after first token
        return { brand, rest };
      }

      // If the user typed a full brand (with space), try closest exact on whole first token
      const brandClosest = resolveClosestBrand(parts[0]);
      if (brandClosest && dealsSuggest.brands.some(b => normalizeStr(b) === normalizeStr(brandClosest))) {
        const rest = raw.slice(parts[0].length).trim();
        return { brand: brandClosest, rest };
      }

      return { brand: "", rest: raw };
    }

    // ---------- Suggestions UI ----------
    const suggestionState = { open: false, items: [], activeIndex: -1, mode: "model" }; // mode: "model" | "brandmodel"

    function closeSuggestions() {
      if (!qSuggestions) return;
      qSuggestions.style.display = "none";
      qSuggestions.innerHTML = "";
      suggestionState.open = false;
      suggestionState.items = [];
      suggestionState.activeIndex = -1;
      suggestionState.mode = "model";
    }

    function renderSuggestions(items, onPick) {
      if (!qSuggestions) return;
      qSuggestions.innerHTML = "";

      if (!items.length) {
        qSuggestions.style.display = "none";
        suggestionState.open = false;
        suggestionState.items = [];
        suggestionState.activeIndex = -1;
        return;
      }

      suggestionState.open = true;
      suggestionState.items = items.slice();
      suggestionState.activeIndex = -1;

      items.forEach((value, idx) => {
        const div = document.createElement("div");
        div.className = "suggestion-item";
        div.textContent = value;
        div.dataset.index = String(idx);

        div.addEventListener("mousedown", (e) => {
          e.preventDefault();
          onPick(value);
        });

        qSuggestions.appendChild(div);
      });

      qSuggestions.style.display = "block";
    }

    function highlightActive() {
      if (!qSuggestions) return;
      const children = Array.from(qSuggestions.querySelectorAll(".suggestion-item"));
      children.forEach(el => el.classList.remove("active"));

      if (suggestionState.activeIndex >= 0 && suggestionState.activeIndex < children.length) {
        const active = children[suggestionState.activeIndex];
        active.classList.add("active");

        const box = qSuggestions;
        const top = active.offsetTop;
        const bottom = top + active.offsetHeight;
        if (top < box.scrollTop) box.scrollTop = top;
        else if (bottom > box.scrollTop + box.clientHeight) box.scrollTop = bottom - box.clientHeight;
      }
    }

    function handleSuggestionKeys(e, onPick) {
      if (!suggestionState.open) return;

      const max = suggestionState.items.length;
      if (!max) return;

      if (e.key === "ArrowDown") {
        e.preventDefault();
        suggestionState.activeIndex = (suggestionState.activeIndex + 1) % max;
        highlightActive();
        return;
      }

      if (e.key === "ArrowUp") {
        e.preventDefault();
        suggestionState.activeIndex = (suggestionState.activeIndex - 1 + max) % max;
        highlightActive();
        return;
      }

      if (e.key === "Enter") {
        if (suggestionState.activeIndex >= 0 && suggestionState.activeIndex < max) {
          e.preventDefault();
          const value = suggestionState.items[suggestionState.activeIndex];
          onPick(value);
        }
        return;
      }

      if (e.key === "Escape") {
        e.preventDefault();
        closeSuggestions();
        return;
      }
    }

    function buildUnifiedSuggestions(typed){
      if (!dealsSuggest.ready) return { items: [], mode: "model", brand: "" };

      const t = String(typed || "").trim();
      if (!t) return { items: [], mode: "model", brand: "" };

      const { brand, rest } = detectBrandPrefix(t);

      // Brand context: suggest "Brand Model"
      if (brand) {
        const pool = dealsSuggest.brandToModels.has(brand)
          ? Array.from(dealsSuggest.brandToModels.get(brand).values()).sort((a,b) => a.localeCompare(b))
          : [];

        const matches = filterSuggestions(pool, rest || "", 12);

        // If rest empty, still show top models (first 12)
        const models = rest ? matches : pool.slice(0, 12);

        return {
          items: models.map(m => `${brand} ${m}`),
          mode: "brandmodel",
          brand,
        };
      }

      // No brand context: suggest model-only
      const matches = filterSuggestions(dealsSuggest.allModels, t, 12);
      return { items: matches, mode: "model", brand: "" };
    }

    function splitBrandModelFromPicked(picked){
      const s = String(picked || "").trim();
      if (!s) return { brand: "", model: "" };

      if (!dealsSuggest.ready) return { brand: "", model: s };

      // Try to parse leading brand (exact match against known brands)
      const parts = s.split(/\s+/).filter(Boolean);
      if (!parts.length) return { brand: "", model: "" };

      // Look for the longest brand that matches the prefix of the string
      let bestBrand = "";
      for (const b of dealsSuggest.brands) {
        const bNorm = normalizeStr(b);
        const sNorm = normalizeStr(s);
        if (sNorm === bNorm || sNorm.startsWith(bNorm + " ")) {
          if (b.length > bestBrand.length) bestBrand = b;
        }
      }

      if (bestBrand) {
        const model = s.slice(bestBrand.length).trim();
        return { brand: bestBrand, model };
      }

      return { brand: "", model: s };
    }

    // Input handlers
    if (qInput) {
      qInput.addEventListener("input", () => {
        const typed = qInput.value.trim();

        if (!typed || typed.length < 1) {
          closeSuggestions();
          updateFetchReady();
          return;
        }

        if (!dealsSuggest.ready) {
          closeSuggestions();
          updateFetchReady();
          return;
        }

        const built = buildUnifiedSuggestions(typed);
        suggestionState.mode = built.mode;

        renderSuggestions(built.items, (value) => {
          // If user picked "Brand Model" (brand context), keep as-is in input
          // If user picked model-only, keep model in input, but we’ll resolve brand on submit.
          const bm = splitBrandModelFromPicked(value);

          if (bm.brand && bm.model) {
            qInput.value = `${bm.brand} ${bm.model}`.trim();
          } else {
            qInput.value = value; // model-only display
          }

          closeSuggestions();
          setTimeout(() => fetchBtn && fetchBtn.focus(), 0);
          updateFetchReady();
        });

        updateFetchReady();
      });

      qInput.addEventListener("keydown", (e) => {
        handleSuggestionKeys(e, (value) => {
          const bm = splitBrandModelFromPicked(value);
          if (bm.brand && bm.model) qInput.value = `${bm.brand} ${bm.model}`.trim();
          else qInput.value = value;
          closeSuggestions();
          setTimeout(() => fetchBtn && fetchBtn.focus(), 0);
          updateFetchReady();
        });
      });

      qInput.addEventListener("blur", () => setTimeout(() => closeSuggestions(), 140));
      qInput.addEventListener("click", () => qInput.select());
    }

    document.addEventListener("click", (e) => {
      const inside = (qSuggestions && qSuggestions.contains(e.target)) || (qInput && qInput.contains(e.target));
      if (!inside) closeSuggestions();
    });

    function syncRibbonFromState(){
      if (ribbonGender) ribbonGender.value = selectedGender || "";
      if (ribbonType) ribbonType.value = selectedShoeType || "";
      if (ribbonSort) ribbonSort.value = currentSort || "";
    }

    function totalPagesCount(total){
      return Math.max(1, Math.ceil((Number(total) || 0) / PAGE_SIZE));
    }

    function updateNavUI(totalFiltered){
      const pager = document.querySelector(".pager");

      if (isMobilePortrait()){
        if (pager) pager.style.display = "none";
        const hasMore = ((pageIndex + 1) * PAGE_SIZE) < (Number(totalFiltered) || 0);
        if (loadMoreWrap) loadMoreWrap.style.display = hasMore ? "flex" : "none";
        return;
      }

      if (loadMoreWrap) loadMoreWrap.style.display = "none";

      const pages = totalPagesCount(totalFiltered);
      const current = Math.min(pageIndex + 1, pages);

      if (pageLabelEl) pageLabelEl.textContent = `${current} of ${pages}`;
      if (prevPageBtn) prevPageBtn.disabled = pageIndex <= 0;
      if (nextPageBtn) nextPageBtn.disabled = (pageIndex + 1) >= pages;

      if (pager) pager.style.display = (pages > 1) ? "flex" : "none";
    }

    // ===== Sort math helpers (price / % off / $ savings) =====
    function toNum(x){
      const n = Number(x);
      return Number.isFinite(n) ? n : null;
    }

    function computePercentOff(item){
      const sale = toNum(item.salePrice);
      const orig = toNum(item.originalPrice);

      if (sale != null && orig != null && orig > 0 && sale < orig) {
        return ((orig - sale) / orig) * 100;
      }

      const pct = toNum(item.discountPercent);
      if (pct != null && pct > 0 && pct < 100) return pct;

      return null;
    }

    function computeSavings(item){
      const sale = toNum(item.salePrice);
      const orig = toNum(item.originalPrice);
      if (sale != null && orig != null && orig > sale) return (orig - sale);
      return null;
    }

    function computePrice(item){
      const sale = toNum(item.salePrice);
      return sale;
    }

    function cmpNullsLast(a, b){
      if (a == null && b == null) return 0;
      if (a == null) return 1;
      if (b == null) return -1;
      return 0;
    }

    function applySort(items){
      const mode = String(currentSort || "").trim();
      if (!mode) return (items || []).slice();

      const arr = (items || []).slice();

      arr.sort((A, B) => {
        if (mode === "price-asc" || mode === "price-desc"){
          const a = computePrice(A), b = computePrice(B);
          const nl = cmpNullsLast(a,b); if (nl) return nl;
          return mode === "price-asc" ? (a - b) : (b - a);
        }

        if (mode === "pct-asc" || mode === "pct-desc"){
          const a = computePercentOff(A), b = computePercentOff(B);
          const nl = cmpNullsLast(a,b); if (nl) return nl;
          return mode === "pct-asc" ? (a - b) : (b - a);
        }

        if (mode === "save-asc" || mode === "save-desc"){
          const a = computeSavings(A), b = computeSavings(B);
          const nl = cmpNullsLast(a,b); if (nl) return nl;
          return mode === "save-asc" ? (a - b) : (b - a);
        }

        return 0;
      });

      return arr;
    }

    // ===== Filters: unified state =====
    function applyFilters(items){
      const gSel = norm(selectedGender);
      const tSel = norm(selectedShoeType);

      return (items || []).filter(item => {
        const g = norm(item.gender);
        const t = norm(item.shoeType);

        const genderOk =
          !gSel ||
          g === gSel ||
          g === "unisex" ||
          g === "unknown" ||
          g === "";

        const typeOk =
          !tSel ||
          t === tSel ||
          t === "unknown" ||
          t === "";

        return genderOk && typeOk;
      });
    }

    function getFilteredAndSorted(items){
      const filtered = applyFilters(items);
      return applySort(filtered);
    }

    // ===== Discount badge helper =====
    function getDiscountInfo(item) {
      const current = Number(item.salePrice);
      const original = Number(item.originalPrice);

      if (Number.isFinite(current) && Number.isFinite(original) && original > 0 && current < original) {
        const pct = Math.round(((original - current) / original) * 100);
        return { hasDiscount: true, current: current.toFixed(2), original: original.toFixed(2), percent: pct };
      }

      const pct2 = Number(item.discountPercent);
      if (Number.isFinite(current) && Number.isFinite(pct2) && pct2 > 0 && pct2 < 100) {
        const origGuess = current / (1 - pct2 / 100);
        if (Number.isFinite(origGuess) && origGuess > current) {
          return { hasDiscount: true, current: current.toFixed(2), original: origGuess.toFixed(2), percent: Math.round(pct2) };
        }
        return { hasDiscount: true, current: current.toFixed(2), original: "", percent: Math.round(pct2) };
      }

      return { hasDiscount: false };
    }

    function renderFilteredResults({ resetPage = true, append = false } = {}) {
      const sorted = getFilteredAndSorted(lastSearchResults);

      if (resetPage) pageIndex = 0;

      const start = pageIndex * PAGE_SIZE;
      const slice = sorted.slice(start, start + PAGE_SIZE);

      if (!append) resultsEl.innerHTML = "";
      slice.forEach(item => resultsEl.appendChild(createDealCard(item)));

      const displayQuery =
        [currentSearch.brand, currentSearch.model].filter(Boolean).join(" ").trim() ||
        (qInput && qInput.value.trim() ? qInput.value.trim() : "all shoes");

      if (!sorted.length) {
        statusMessageEl.textContent = `No results match your filters for ${displayQuery}.`;
        updateNavUI(0);
        return;
      }

      statusMessageEl.textContent =
        `We found ${sorted.length} deal${sorted.length === 1 ? "" : "s"} on ${displayQuery} shoes.`;

      updateNavUI(sorted.length);
    }

    function renderDailyDealsNow(){
      if (!dailyDealsGrid) return;
      if (!lastDailyDeals || !lastDailyDeals.length) return;

      const sorted = getFilteredAndSorted(lastDailyDeals);

      dailyDealsGrid.innerHTML = "";
      sorted.forEach(item => dailyDealsGrid.appendChild(createDealCard(item)));

      if (dailyDeals) dailyDeals.style.display = sorted.length ? "block" : "none";
    }

    // ===== Ribbon listeners =====
    if (ribbonGender){
      ribbonGender.addEventListener("change", () => {
        selectedGender = norm(ribbonGender.value);
        renderDailyDealsNow();
        renderFilteredResults({ resetPage: true, append: false });
      });
    }

    if (ribbonType){
      ribbonType.addEventListener("change", () => {
        selectedShoeType = norm(ribbonType.value);
        renderDailyDealsNow();
        renderFilteredResults({ resetPage: true, append: false });
      });
    }

    if (ribbonSort){
      ribbonSort.addEventListener("change", () => {
        currentSort = String(ribbonSort.value || "").trim();
        renderDailyDealsNow();
        renderFilteredResults({ resetPage: true, append: false });
      });
    }

    // ===== Paging / load more =====
    if (loadMoreBtn) {
      loadMoreBtn.addEventListener("click", () => {
        const sorted = getFilteredAndSorted(lastSearchResults);
        const total = sorted.length;

        const hasMore = ((pageIndex + 1) * PAGE_SIZE) < total;
        if (!hasMore) return;

        pageIndex++;
        renderFilteredResults({ resetPage: false, append: true });
      });
    }

    if (prevPageBtn) {
      prevPageBtn.addEventListener("click", () => {
        if (pageIndex <= 0) return;

        runPagerTransitionThen(() => {
          pageIndex--;
          renderFilteredResults({ resetPage: false, append: false });
          resultsEl.scrollIntoView({ behavior: "smooth", block: "start" });
        });
      });
    }

    if (nextPageBtn) {
      nextPageBtn.addEventListener("click", () => {
        const sorted = getFilteredAndSorted(lastSearchResults);
        const pages = totalPagesCount(sorted.length);
        if (pageIndex >= pages - 1) return;

        runPagerTransitionThen(() => {
          pageIndex++;
          renderFilteredResults({ resetPage: false, append: false });
          resultsEl.scrollIntoView({ behavior: "smooth", block: "start" });
        });
      });
    }

    function createDealCard(item) {
      const discount = getDiscountInfo(item);

      const card = document.createElement("div");
      card.className = "card";

      const link = document.createElement("a");
      link.className = "card-link";

      const listingUrl = item.listingURL;
      const safeLink = isValidRetailerUrl(listingUrl) ? listingUrl : "#";
      if (safeLink === "#" && listingUrl) console.warn("Blocked untrusted retailer URL:", listingUrl);

      link.href = safeLink;
      link.target = "_blank";
      link.rel = "noopener noreferrer";

      const imgWrapper = document.createElement("div");
      imgWrapper.className = "card-image-wrapper";

      const img = document.createElement("img");
      img.src = item.imageURL ? item.imageURL : "https://placehold.co/600x400?text=Running+Shoe";
      img.alt = (item.brand && item.model) ? `${item.brand} ${item.model}` : (item.model || item.brand || "Running shoe deal");
      imgWrapper.appendChild(img);

      if (discount.hasDiscount) {
        const badge = document.createElement("div");
        badge.className = "discount-badge";
        badge.textContent = `${discount.percent}% OFF`;
        imgWrapper.appendChild(badge);
      }

      const gRaw = norm(item.gender);
      const tRaw = norm(item.shoeType);

      const g = (gRaw && gRaw !== "unknown") ? gRaw : "";
      const t = (tRaw && tRaw !== "unknown") ? tRaw : "";

      const tagWrap = document.createElement("div");
      tagWrap.className = "card-tags";

      let hasAnyTag = false;

      if (g) {
        const genderTag = document.createElement("span");
        genderTag.className = "card-tag";
        genderTag.textContent = g === "mens" ? "Mens" : g === "womens" ? "Womens" : "Unisex";
        tagWrap.appendChild(genderTag);
        hasAnyTag = true;
      }

      if (t) {
        const typeTag = document.createElement("span");
        typeTag.className = "card-tag";
        typeTag.textContent =
          t === "road" ? "Road" :
          t === "trail" ? "Trail" :
          t === "track" ? "Spikes" : (item.shoeType || "");
        tagWrap.appendChild(typeTag);
        hasAnyTag = true;
      }

      if (hasAnyTag) imgWrapper.appendChild(tagWrap);

      link.appendChild(imgWrapper);

      const contentDiv = document.createElement("div");
      contentDiv.className = "card-content";

      const titleDiv = document.createElement("div");
      titleDiv.className = "card-title";

      const brand = (item.brand || "").trim();
      const model = (item.model || "").trim();

      if (brand && model) {
        titleDiv.innerHTML = `<strong style="text-transform: uppercase;">${brand}</strong><br>${model}`;
      } else if (brand) {
        titleDiv.innerHTML = `<strong style="text-transform: uppercase;">${brand}</strong>`;
      } else if (model) {
        titleDiv.textContent = model;
      } else {
        titleDiv.textContent = "Deal";
      }

      contentDiv.appendChild(titleDiv);

      if (item.store) {
        const storeDiv = document.createElement("div");
        storeDiv.className = "card-store";
        storeDiv.textContent = item.store;
        contentDiv.appendChild(storeDiv);
      }

      const priceRow = document.createElement("div");
      priceRow.className = "card-price-row";

      const priceSpan = document.createElement("span");
      priceSpan.className = "price";

      const currentPrice = Number(item.salePrice);
      if (Number.isFinite(currentPrice)) priceSpan.textContent = `$${currentPrice.toFixed(2)}`;
      else priceSpan.textContent = item.salePrice != null ? String(item.salePrice) : "—";

      priceRow.appendChild(priceSpan);

      if (discount.hasDiscount && discount.original) {
        const origSpan = document.createElement("span");
        origSpan.className = "card-original-price";
        origSpan.textContent = `$${discount.original}`;
        priceRow.appendChild(origSpan);
      }

      contentDiv.appendChild(priceRow);
      link.appendChild(contentDiv);

      card.appendChild(link);
      return card;
    }

    async function loadDailyDeals() {
      try {
        const url = blobUrl("twelve_daily_deals.json");
        const res = await fetch(url);

        if (!res.ok) {
          console.error("Failed to fetch daily deals:", res.status, res.statusText);
          if (dailyDeals) dailyDeals.style.display = "none";
          return;
        }

        const data = await res.json();
        const deals = Array.isArray(data.deals) ? data.deals : [];
        lastDailyDeals = deals.slice();

        if (!deals.length) {
          if (dailyDeals) dailyDeals.style.display = "none";
          return;
        }

        renderDailyDealsNow();
        if (dailyDeals) dailyDeals.style.display = "block";
      } catch (err) {
        console.error("Error loading daily deals:", err);
        if (dailyDeals) dailyDeals.style.display = "none";
      }
    }

    loadDailyDeals();

    // Build suggestions from deals.json (main page)
    loadDealsSuggestionIndex();

    function updateToTopVisibility(){
      if (!toTopBtn) return;

      if (!isMobilePortrait()){
        toTopBtn.classList.remove("is-visible");
        return;
      }

      if (window.scrollY > 250)
        toTopBtn.classList.add("is-visible");
      else
        toTopBtn.classList.remove("is-visible");
    }

    window.addEventListener("scroll", updateToTopVisibility, { passive: true });
    window.addEventListener("resize", updateToTopVisibility);
    updateToTopVisibility();

    if (toTopBtn){
      toTopBtn.addEventListener("click", () => {
        window.scrollTo({ top: 0, behavior: "smooth" });
      });
    }

    function expandInputs(){
      if (!appEl) return;
      if (!isMobilePortrait()) return;
      appEl.classList.add("inputs-expanded");
    }

    function shrinkInputs(){
      if (!appEl) return;
      if (!isMobilePortrait()) return;

      const input = qInput;

      setTimeout(() => {
        const stillFocused = (document.activeElement === input);
        const anyText = (input && (input.value || "").trim().length > 0);

        if (stillFocused) return;
        if (anyText) return;

        appEl.classList.remove("inputs-expanded");
      }, 0);
    }

    if (qInput) qInput.addEventListener("focus", expandInputs);
    if (qInput) qInput.addEventListener("blur", shrinkInputs);

    document.addEventListener("focusin", () => {
      if (!isMobilePortrait()) return;
      const active = document.activeElement;
      const inInputs = (active === qInput);
      if (!inInputs) shrinkInputs();
    });

    // ---- Submit (resolve to brand+model when possible) ----
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      shrinkInputs();

      const typedRaw = sanitizeInput(qInput.value);
      updateFetchReady();

      if (!typedRaw) {
        statusMessageEl.textContent = "Please enter a brand and/or a model.";
        return;
      }

      // Parse typed into brand/model if possible
      let { brand, model } = splitBrandModelFromPicked(typedRaw);

      // If brand is missing, try to infer from model (definitive only)
      if (!brand && model && dealsSuggest.ready) {
        const exactBrand = dealsSuggest.modelNormToBrandDisplay.get(normalizeStr(model)) || "";
        const inferred = exactBrand || inferDefinitiveBrandFromPartialModel(model);
        if (inferred) brand = inferred;
      }

      // Clean brand spelling to canonical (when present)
      if (brand) brand = resolveClosestBrand(brand);

      // Final query string sent to API
      const displayQuery = [brand, model].filter(Boolean).join(" ").trim();
      if (!displayQuery) {
        statusMessageEl.textContent = "Please enter a brand and/or a model.";
        return;
      }

      currentSearch = { brand, model };

      statusMessageEl.textContent = "Searching deals…";
      resultsEl.innerHTML = "";

      const pager = document.querySelector(".pager");
      if (pager) pager.style.display = "none";
      if (loadMoreWrap) loadMoreWrap.style.display = "none";
      if (dailyDeals) dailyDeals.style.display = "none";

      let data;
      try {
        const res = await fetch("/api/search?" + new URLSearchParams({ query: displayQuery }));
        data = await res.json();
      } catch (err) {
        console.error("Search error:", err);
        statusMessageEl.textContent = "Search failed. Please try again.";
        if (dailyDeals) dailyDeals.style.display = "block";
        return;
      }

      const results = (data && data.results) ? data.results : [];
      lastSearchResults = results;

      // Reset filters + sort on new search
      selectedGender = "";
      selectedShoeType = "";
      currentSort = "";
      syncRibbonFromState();

      if (!results.length) {
        statusMessageEl.textContent = `No results found for ${displayQuery}.`;
        if (pager) pager.style.display = "none";
        if (loadMoreWrap) loadMoreWrap.style.display = "none";
        if (dailyDeals) dailyDeals.style.display = "block";
        return;
      }

      renderFilteredResults({ resetPage: true, append: false });
    });

    if (qInput) qInput.addEventListener("input", updateFetchReady);
  })();
  </script>

  <!-- ===== Set Alert Modal (drop-in) ===== -->
  <!-- (UNCHANGED: your modal stays brand+model, using brandModels.js as designed) -->
  <div id="sbAlertBackdrop" class="sb-alert-backdrop" aria-hidden="true">
    <div class="sb-alert-modal" role="dialog" aria-modal="true" aria-labelledby="sbAlertTitle">
      <button type="button" class="sb-alert-close" id="sbAlertClose" aria-label="Close">×</button>

      <div class="sb-alert-title" id="sbAlertTitle">Set Alert</div>

      <form id="sbSetAlertForm" class="sb-alert-form">
        <!-- FORM VIEW -->
        <div id="sbAlertFormView">
          <div class="sb-input-wrap">
            <input class="sb-input" type="email" id="sbAlertEmail" placeholder="your@email.com" required autocomplete="email">
            <button type="button" class="sb-clear" data-clear="#sbAlertEmail" aria-label="Clear email">×</button>
          </div>

          <div class="sb-input-wrap">
            <input class="sb-input" type="text" id="sbAlertBrand" placeholder="Enter shoe brand..." autocomplete="off" required>
            <button type="button" class="sb-clear" data-clear="#sbAlertBrand" aria-label="Clear brand">×</button>
            <div id="sbBrandSug" class="sb-sug" hidden></div>
          </div>

          <div class="sb-input-wrap">
            <input class="sb-input" type="text" id="sbAlertModel" placeholder="Enter shoe model..." autocomplete="off" required>
            <button type="button" class="sb-clear" data-clear="#sbAlertModel" aria-label="Clear model">×</button>
            <div id="sbModelSug" class="sb-sug" hidden></div>
          </div>

          <div class="sb-row">
            <div class="sb-col">
              <div class="sb-gender" id="sbGender">
                <div class="sb-gender-option" data-g="womens" role="radio" aria-checked="false" tabindex="0">
                  <span class="sb-gender-box"><span class="sb-gender-check">✓</span></span>
                  <span class="sb-gender-label">Women’s</span>
                </div>
                <div class="sb-gender-option" data-g="mens" role="radio" aria-checked="false" tabindex="0">
                  <span class="sb-gender-box"><span class="sb-gender-check">✓</span></span>
                  <span class="sb-gender-label">Men’s</span>
                </div>
              </div>
            </div>

            <div class="sb-col sb-price-col">
              <div class="sb-price-wrap">
                <span class="sb-dollar">$</span>
                <input class="sb-input sb-price"
                       type="text"
                       id="sbAlertPrice"
                       placeholder="Enter whole dollars."
                       inputmode="numeric"
                       autocomplete="off"
                       aria-label="Target price in whole dollars"
                       required>

                <button type="button" class="sb-clear sb-clear-price" data-clear="#sbAlertPrice" aria-label="Clear price">×</button>
              </div>
            </div>
          </div>

          <button type="submit" class="sb-submit" id="sbSetAlertBtn">Set Alert</button>

          <div class="sb-note">
            <div class="sb-note-title">Important</div>
            <ul>
              <li>Your email will never be sold or shared by Shoe Beagle, and will only be used for alert confirmation and notification.</li>
            </ul>
          </div>

          <div id="sbStatus" class="sb-status" hidden></div>
        </div>

        <!-- SUCCESS VIEW -->
        <div id="sbConfirm" class="sb-confirm" hidden>
          <div class="sb-confirm-title">✓ Alert Set Successfully!</div>
          <div id="sbConfirmDetails" class="sb-confirm-details"></div>
          <div class="sb-confirm-msg">
            You’ll receive a confirmation email shortly. If we find your shoes at or below your target price, we’ll email you immediately. This alert expires in 30 days.
          </div>
          <button type="button" class="sb-submit sb-secondary" id="sbSetAnother">Set Another Alert</button>
        </div>

        <!-- MAXED OUT VIEW -->
        <div id="sbMaxed" class="sb-confirm" hidden>
          <div class="sb-confirm-title">Alert Limit Reached</div>
          <div class="sb-confirm-details" style="border-color: rgba(220,53,69,0.35);">
            <div style="font-weight:800; color:#214478ff; margin-bottom:6px;">You’ve reached the maximum number of alerts.</div>
            <div style="line-height:1.45;">
              If you want to set another alert, open your confirmation email and use the secure link inside it to remove an existing alert first.
            </div>
          </div>
          <button type="button" class="sb-submit sb-secondary" id="sbMaxedClose">Close</button>
        </div>
      </form>
    </div>
  </div>

  <!-- ===== Modal controller (UNCHANGED) ===== -->
  <script>
  /* KEEP your existing modal controller script exactly as-is.
     Paste it here unchanged (I omitted it in this snippet to keep focus on the main-page change). */
  </script>

</body>
</html>
