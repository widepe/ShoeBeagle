<!-- /pages/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="/images/favicon.svg">
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self';
                 script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com;
                 img-src * data: https:;
                 style-src 'self' 'unsafe-inline';
                 connect-src 'self' https://v3gjlrmpc76mymfc.public.blob.vercel-storage.com;
                 font-src 'self';
                 frame-src 'none';">
  <title>Shoe Beagle--The Running Shoe Deal Finder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- CSS split -->
  <link rel="stylesheet" href="/pages/index.css?v=89">

  <!--
    IMPORTANT:
    Set this at deploy time to avoid hardcoding the blob store base.
    Example value:
      https://v3gjlrmpc76mymfc.public.blob.vercel-storage.com
  -->
  <meta name="shoebeagle-blob-base" content="__BLOB_BASE_URL__">
</head>

<body>
  <div class="app">
    <img class="mobile-top-banner" src="/images/logo_heading.svg" alt="">

    <!-- TOP AREA: inputs left, logo right -->
    <div class="topbar">
      <div class="top-left">
        <form id="search-form" method="POST" autocomplete="off">

          <!-- SINGLE SEARCH ROW: unified input + menu + fetch -->
          <div class="row">
            <div class="input-wrapper">
              <img class="input-icon" src="/images/mg.svg" alt="" aria-hidden="true">
              <input id="q" type="text" placeholder="Search brand or model..." autocomplete="off"/>
              <button type="button" class="input-clear" aria-label="Clear search">&times;</button>
              <div id="qSuggestions" class="suggestions"></div>
            </div>

   <div class="button-wrapper">
  <button id="fetchBtn" type="submit" class="btn-eq" aria-label="Fetch">
    <img src="/images/fetch.svg" class="btn-icon" alt="Fetch">
  </button>
</div>

<div class="button-wrapper">
  <button id="menuBtn"
          type="button"
          class="btn-eq"
          aria-label="Links"
          aria-expanded="false"
          aria-controls="linksRibbon">
    <img src="/images/menu.svg" class="btn-icon" alt="Links">
  </button>
</div>

          </div>

        </form>
      </div>

      <!-- LOGO RIGHT -->
      <div class="top-right">
        <img
          src="/images/logo.svg"
          class="brand-logo"
          alt="Shoe Beagle Logo"
          id="logoLink"
        >
      </div>
    </div>

    <!-- Links ribbon (hidden by default; toggled by the button above) -->
    <div id="linksRibbon" class="links-ribbon" style="display:none;">
      <div class="links-ribbon-inner">

        <!-- LEFT: Set Alert -->
        <div class="links-ribbon-left">
          <a class="links-ribbon-link" href="#" data-open-alert>Set Alert</a>
        </div>

        <!-- CENTER: Filter + Sort dropdowns -->
        <div class="links-ribbon-center">
          <div class="ribbon-controls" role="group" aria-label="Filter and sort">

            <label class="ribbon-label" for="ribbonGender">Gender</label>
            <select id="ribbonGender" class="ribbon-select" aria-label="Filter by gender">
              <option value="" selected>Off</option>
              <option value="mens">Mens</option>
              <option value="womens">Womens</option>
            </select>

            <label class="ribbon-label" for="ribbonType">Shoe Type</label>
            <select id="ribbonType" class="ribbon-select" aria-label="Filter by shoe type">
              <option value="" selected>Off</option>
              <option value="road">Road</option>
              <option value="trail">Trail</option>
              <option value="track">Track</option>
            </select>

            <label class="ribbon-label" for="ribbonSort">Sort</label>
            <select id="ribbonSort" class="ribbon-select" aria-label="Sort results">
              <option value="" selected>Off</option>
              <option value="price-asc">Price: Lo → Hi</option>
              <option value="price-desc">Price: Hi → Lo</option>
              <option value="pct-asc">% Off: Lo → Hi</option>
              <option value="pct-desc">% Off: Hi → Lo</option>
              <option value="save-asc">Savings: Lo → Hi</option>
              <option value="save-desc">Savings: Hi → Lo</option>
            </select>

          </div>
        </div>

        <!-- RIGHT: Favorites + close -->
        <div class="links-ribbon-right">
          <a class="links-ribbon-link is-disabled" href="#" aria-disabled="true" tabindex="0">Favorites</a>
          <button type="button" class="chip-close" aria-label="Close links">×</button>
        </div>

      </div>
    </div>

    <div id="mainContent">
      <div class="status-message" id="statusMessage">
        Marty’s Daily Deals
      </div>

      <div class="daily-deals" id="dailyDeals">
        <div class="shoe-grid" id="dailyDealsGrid"></div>
      </div>

      <div class="shoe-grid" id="results"></div>

      <div class="load-more-wrap" id="loadMoreWrap" style="display:none;">
        <button id="loadMoreBtn" class="load-more-btn" type="button">Load more</button>
      </div>

      <div class="pager">
        <button id="prevPage" class="pager-btn" aria-label="Previous page">◀</button>
        <div id="pageLabel" class="page-label">1 / 1</div>
        <button id="nextPage" class="pager-btn" aria-label="Next page">▶</button>
      </div>

      <p class="disclaimer">
        Shoe Beagle may earn commissions through our affiliate program at no cost to you.
        We do not sell products directly and are not responsible for changes in price, availability,
        or shipping terms on retailer sites.
      </p>
    </div>

    <div class="footer">
      <div class="footer-links">
        <a href="/pages/about.html">About</a> |
        <a href="/pages/contact.html">Contact</a> |
        <a href="/pages/privacy.html">Privacy</a> |
        <a href="/pages/terms.html">Terms</a>
      </div>

      <div class="footer-copy">
        © <span id="footerYear"></span> Shoe Beagle. All rights reserved.
      </div>
    </div>

    <button class="to-top" id="toTopBtn" type="button" aria-label="Back to top">↑</button>
  </div>

  <!-- Load brand/models once (root) -->
  <!-- NOTE: main page no longer uses brandModels.js for suggestions.
       Modal still uses it (by design). -->
  <script src="/brandModels.js"></script>

  <!-- ===== Main Page Script ===== -->
  <script>
  (() => {
    const form = document.getElementById("search-form");

    const statusMessageEl = document.getElementById("statusMessage");
    const resultsEl = document.getElementById("results");
    const dailyDeals = document.getElementById("dailyDeals");
    const dailyDealsGrid = document.getElementById("dailyDealsGrid");
    const fetchBtn = document.getElementById("fetchBtn");

    // Unified input + suggestions
    const qInput = document.getElementById("q");
    const qSuggestions = document.getElementById("qSuggestions");

    const logoLink = document.getElementById("logoLink");
    const footerYear = document.getElementById("footerYear");
    const appEl = document.querySelector(".app");

    // Links toggle button + ribbon
    const menuBtn = document.getElementById("menuBtn");
    const linksRibbon = document.getElementById("linksRibbon");
    const linksRibbonClose = linksRibbon?.querySelector(".chip-close");

    // Ribbon dropdowns
    const ribbonGender = document.getElementById("ribbonGender");
    const ribbonType   = document.getElementById("ribbonType");
    const ribbonSort   = document.getElementById("ribbonSort");

    const PAGE_SIZE = 12;
    let pageIndex = 0;

    const prevPageBtn = document.getElementById("prevPage");
    const nextPageBtn = document.getElementById("nextPage");
    const pageLabelEl = document.getElementById("pageLabel");

    // Load more elements
    const loadMoreWrap = document.getElementById("loadMoreWrap");
    const loadMoreBtn = document.getElementById("loadMoreBtn");
    const toTopBtn = document.getElementById("toTopBtn");

    function isMobilePortrait(){
      return window.matchMedia("(max-width: 560px) and (orientation: portrait)").matches;
    }

    function runPagerTransitionThen(fn){
      if (isMobilePortrait()) { fn(); return; }
      resultsEl.classList.add("is-switching");
      setTimeout(() => {
        fn();
        requestAnimationFrame(() => {
          resultsEl.classList.remove("is-switching");
        });
      }, 160);
    }

    // Current search state (still brand+model under the hood)
    let currentSearch = { brand: "", model: "" };
    let lastSearchResults = [];
    let lastDailyDeals = [];

    // Unified state (ribbon dropdowns update these)
    let selectedGender = "";      // "" | "mens" | "womens"
    let selectedShoeType = "";    // "" | "road" | "trail" | "track"
    let currentSort = "";         // "" | "price-asc" | "price-desc" | "pct-asc" | "pct-desc" | "save-asc" | "save-desc"

    if (footerYear) footerYear.textContent = new Date().getFullYear();
    if (logoLink) logoLink.addEventListener("click", () => location.reload());

    // --- Links ribbon toggle ---
    function isRibbonOpen(){
      return !!(linksRibbon && linksRibbon.style.display !== "none");
    }
    function openRibbon(){
      if (!linksRibbon) return;
      linksRibbon.style.display = "block";
      if (menuBtn) menuBtn.setAttribute("aria-expanded", "true");
    }
    function closeRibbon(){
      if (!linksRibbon) return;
      linksRibbon.style.display = "none";
      if (menuBtn) menuBtn.setAttribute("aria-expanded", "false");
    }
    function toggleRibbon(){
      if (!linksRibbon) return;
      if (isRibbonOpen()) closeRibbon();
      else openRibbon();
    }

    if (menuBtn) {
      menuBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        toggleRibbon();
      });
    }

    if (linksRibbonClose) {
      linksRibbonClose.addEventListener("click", (e) => {
        e.preventDefault();
        closeRibbon();
      });
    }

    // --- Helpers ---
    function normalizeStr(s) { return String(s || "").trim().toLowerCase(); }
    function norm(s) { return String(s || "").trim().toLowerCase(); }

    function sanitizeInput(str) {
      return String(str || "")
        .replace(/[<>'"]/g, '')
        .replace(/script/gi, '')
        .replace(/javascript:/gi, '')
        .replace(/on\w+=/gi, '')
        .trim()
        .slice(0, 100);
    }

    function squashStr(s) { return String(s || "").toLowerCase().replace(/[^a-z0-9]/g, ""); }

    function updateFetchReady() {
      const hasAny = !!(qInput && qInput.value.trim());
      if (fetchBtn) fetchBtn.disabled = !hasAny;
    }
    updateFetchReady();

    // Clear button (single)
    const clearBtn = document.querySelector('.input-clear');
    if (clearBtn) {
      clearBtn.addEventListener('click', (e) => {
        e.preventDefault();
        if (qInput) {
          qInput.value = '';
          qInput.focus();
          closeSuggestions();
          updateFetchReady();
        }
      });
    }

    function isValidRetailerUrl(url) {
      if (!url || url === '#') return false;
      try {
        const u = new URL(url);
        return u.protocol === "https:" || u.protocol === "http:";
      } catch {
        return false;
      }
    }

    // --- Blob base ---
    function getBlobBase() {
      const meta = document.querySelector('meta[name="shoebeagle-blob-base"]');
      const fromMeta = meta ? String(meta.getAttribute("content") || "").trim() : "";
      const looksLikePlaceholder = fromMeta.includes("__BLOB_BASE_URL__");
      if (fromMeta && !looksLikePlaceholder) return fromMeta.replace(/\/+$/, "");
      return "https://v3gjlrmpc76mymfc.public.blob.vercel-storage.com";
    }

    function blobUrl(path) {
      const base = getBlobBase();
      const cleanPath = String(path || "").replace(/^\/+/, "");
      return base.replace(/\/+$/, "") + "/" + cleanPath;
    }

    // ===============================
    // Suggestions index = deals.json ONLY
    // ===============================
    const dealsSuggest = {
      ready: false,
      brandNormToDisplay: new Map(),      // normBrand -> "Nike"
      brandToModels: new Map(),           // "Nike" -> Map(normModel -> "Pegasus 42")
      allModelsNormToDisplay: new Map(),  // normModel -> "Pegasus 42"
      modelNormToBrandDisplay: new Map(), // normModel -> "Nike" (first brand wins)
      brands: [],
      allModels: [],
    };

    async function loadDealsSuggestionIndex(){
      try {
        const url = blobUrl("deals.json");
        const res = await fetch(`${url}${url.includes("?") ? "&" : "?"}cb=${Date.now()}`, { cache: "no-store" });
        if (!res.ok) throw new Error(`deals.json fetch failed: ${res.status}`);

        const data = await res.json();
        const deals = Array.isArray(data?.deals) ? data.deals : [];

        dealsSuggest.brandNormToDisplay.clear();
        dealsSuggest.brandToModels.clear();
        dealsSuggest.allModelsNormToDisplay.clear();
        dealsSuggest.modelNormToBrandDisplay.clear();

        for (const d of deals) {
          const brandRaw = String(d?.brand || "").trim();
          const modelRaw = String(d?.model || "").trim();

          if (brandRaw) {
            const bNorm = normalizeStr(brandRaw);

            if (!dealsSuggest.brandNormToDisplay.has(bNorm)) {
              dealsSuggest.brandNormToDisplay.set(bNorm, brandRaw);
            }

            const bDisplay = dealsSuggest.brandNormToDisplay.get(bNorm);

            if (!dealsSuggest.brandToModels.has(bDisplay)) {
              dealsSuggest.brandToModels.set(bDisplay, new Map());
            }

            if (modelRaw) {
              const mNorm = normalizeStr(modelRaw);
              const modelMap = dealsSuggest.brandToModels.get(bDisplay);
              if (!modelMap.has(mNorm)) modelMap.set(mNorm, modelRaw);

              if (!dealsSuggest.modelNormToBrandDisplay.has(mNorm)) {
                dealsSuggest.modelNormToBrandDisplay.set(mNorm, bDisplay);
              }
            }
          }

          if (modelRaw) {
            const mNorm = normalizeStr(modelRaw);
            if (!dealsSuggest.allModelsNormToDisplay.has(mNorm)) {
              dealsSuggest.allModelsNormToDisplay.set(mNorm, modelRaw);
            }
          }
        }

        dealsSuggest.brands = Array.from(dealsSuggest.brandNormToDisplay.values()).sort((a,b) => a.localeCompare(b));
        dealsSuggest.allModels = Array.from(dealsSuggest.allModelsNormToDisplay.values()).sort((a,b) => a.localeCompare(b));
        dealsSuggest.ready = true;
      } catch (e) {
        console.error("[suggestions] Failed to build deals.json suggestion index:", e?.message || String(e));
        dealsSuggest.ready = false;
        dealsSuggest.brands = [];
        dealsSuggest.allModels = [];
      }
    }

    function inferDefinitiveBrandFromPartialModel(modelTyped){
      if (!dealsSuggest.ready) return "";
      const q = squashStr(modelTyped);
      if (!q || q.length < 3) return "";

      const brandsFound = new Set();

      for (const modelDisplay of dealsSuggest.allModels) {
        const mSquash = squashStr(modelDisplay);
        if (!mSquash.includes(q)) continue;

        const b = dealsSuggest.modelNormToBrandDisplay.get(normalizeStr(modelDisplay)) || "";
        if (b) brandsFound.add(b);

        if (brandsFound.size > 1) return ""; // ambiguous
      }

      return brandsFound.size === 1 ? Array.from(brandsFound)[0] : "";
    }

    // "closest brand" based ONLY on deals.json brands (used for parsing brand prefix)
    function levenshtein(a, b) {
      a = String(a || "");
      b = String(b || "");
      const m = a.length, n = b.length;
      if (!m) return n;
      if (!n) return m;

      const dp = new Array(n + 1);
      for (let j = 0; j <= n; j++) dp[j] = j;

      for (let i = 1; i <= m; i++) {
        let prev = dp[0];
        dp[0] = i;
        for (let j = 1; j <= n; j++) {
          const temp = dp[j];
          const cost = a[i - 1] === b[j - 1] ? 0 : 1;
          dp[j] = Math.min(dp[j] + 1, dp[j - 1] + 1, prev + cost);
          prev = temp;
        }
      }
      return dp[n];
    }

    function resolveClosestBrand(input) {
      const raw = String(input || "").trim();
      if (!raw) return "";
      if (!dealsSuggest.ready || !dealsSuggest.brands.length) return raw;

      const exact = dealsSuggest.brands.find(b => normalizeStr(b) === normalizeStr(raw));
      if (exact) return exact;

      const q = squashStr(raw);
      if (!q) return raw;

      let best = null;
      let bestDist = Infinity;

      for (const b of dealsSuggest.brands) {
        const bs = squashStr(b);
        const d = levenshtein(q, bs);
        if (d < bestDist) {
          bestDist = d;
          best = b;
        }
      }

      const len = q.length;
      const threshold = len <= 4 ? 1 : (len <= 7 ? 2 : 3);
      return (best != null && bestDist <= threshold) ? best : raw;
    }

    function scoreSuggestion(candidate, query) {
      const c = String(candidate || "");
      const cl = c.toLowerCase();
      const q = String(query || "").trim().toLowerCase();
      if (!q) return 0;

      const cSquash = squashStr(c);
      const qSquash = squashStr(q);

      let score = 0;
      if (cl.startsWith(q)) score += 120;
      if (cl.includes(q)) score += 80;
      if (qSquash.length >= 3 && cSquash.includes(qSquash)) score += 110;

      const qParts = q.split(/\s+/).filter(Boolean);
      if (qParts.length >= 2) {
        const cParts = cl.split(/\s+/);
        let tokenHits = 0;
        for (const qp of qParts) {
          if (cParts.some(cp => cp.startsWith(qp))) tokenHits++;
        }
        score += tokenHits * 25;
      }

      score -= Math.min(c.length, 30) * 0.25;
      return score;
    }

    function filterSuggestions(list, typed, limit = 10) {
      const q = String(typed || "").trim();
      if (!q) return [];

      const qLower = q.toLowerCase();
      const starts = list.filter(v => String(v).toLowerCase().startsWith(qLower));
      if (starts.length) {
        const ranked = starts
          .map(v => ({ v, s: scoreSuggestion(v, q) }))
          .sort((a, b) => (b.s - a.s) || (String(a.v).length - String(b.v).length) || String(a.v).localeCompare(String(b.v)))

          .slice(0, limit)
          .map(x => x.v);
        return Array.from(new Set(ranked));
      }

      const scored = list
        .map(v => ({ v, s: scoreSuggestion(v, q) }))
        .filter(x => x.s > 0)
        .sort((a, b) => (b.s - a.s) || (String(a.v).length - String(b.v).length) || String(a.v).localeCompare(String(b.v)))

        .slice(0, limit)
        .map(x => x.v);

      return Array.from(new Set(scored));
    }

    // ---------- Unified suggestion behavior ----------
    // If user starts with a brand prefix (unique), show "Brand Model" suggestions.
    // Otherwise, show model-only suggestions.
    function detectBrandPrefix(typed){
      if (!dealsSuggest.ready) return { brand: "", rest: typed };

      const raw = String(typed || "").trim();
      if (!raw) return { brand: "", rest: "" };

      // Consider first token as brand prefix (nike, asics, saucony...)
      const parts = raw.split(/\s+/).filter(Boolean);
      if (!parts.length) return { brand: "", rest: raw };

      const first = parts[0];
      if (first.length < 2) return { brand: "", rest: raw };

      const firstNorm = squashStr(first);
      const matches = dealsSuggest.brands.filter(b => squashStr(b).startsWith(firstNorm));

      if (matches.length === 1) {
        const brand = matches[0];
        const rest = raw.slice(parts[0].length).trim(); // remainder after first token
        return { brand, rest };
      }

      // If the user typed a full brand (with space), try closest exact on whole first token
      const brandClosest = resolveClosestBrand(parts[0]);
      if (brandClosest && dealsSuggest.brands.some(b => normalizeStr(b) === normalizeStr(brandClosest))) {
        const rest = raw.slice(parts[0].length).trim();
        return { brand: brandClosest, rest };
      }

      return { brand: "", rest: raw };
    }

    // ---------- Suggestions UI ----------
    const suggestionState = { open: false, items: [], activeIndex: -1, mode: "model" }; // mode: "model" | "brandmodel"

    function closeSuggestions() {
      if (!qSuggestions) return;
      qSuggestions.style.display = "none";
      qSuggestions.innerHTML = "";
      suggestionState.open = false;
      suggestionState.items = [];
      suggestionState.activeIndex = -1;
      suggestionState.mode = "model";
    }

    function renderSuggestions(items, onPick) {
      if (!qSuggestions) return;
      qSuggestions.innerHTML = "";

      if (!items.length) {
        qSuggestions.style.display = "none";
        suggestionState.open = false;
        suggestionState.items = [];
        suggestionState.activeIndex = -1;
        return;
      }

      suggestionState.open = true;
      suggestionState.items = items.slice();
      suggestionState.activeIndex = -1;

      items.forEach((value, idx) => {
        const div = document.createElement("div");
        div.className = "suggestion-item";
        div.textContent = value;
        div.dataset.index = String(idx);

        div.addEventListener("mousedown", (e) => {
          e.preventDefault();
          onPick(value);
        });

        qSuggestions.appendChild(div);
      });

      qSuggestions.style.display = "block";
    }

    function highlightActive() {
      if (!qSuggestions) return;
      const children = Array.from(qSuggestions.querySelectorAll(".suggestion-item"));
      children.forEach(el => el.classList.remove("active"));

      if (suggestionState.activeIndex >= 0 && suggestionState.activeIndex < children.length) {
        const active = children[suggestionState.activeIndex];
        active.classList.add("active");

        const box = qSuggestions;
        const top = active.offsetTop;
        const bottom = top + active.offsetHeight;
        if (top < box.scrollTop) box.scrollTop = top;
        else if (bottom > box.scrollTop + box.clientHeight) box.scrollTop = bottom - box.clientHeight;
      }
    }

    function handleSuggestionKeys(e, onPick) {
      if (!suggestionState.open) return;

      const max = suggestionState.items.length;
      if (!max) return;

      if (e.key === "ArrowDown") {
        e.preventDefault();
        suggestionState.activeIndex = (suggestionState.activeIndex + 1) % max;
        highlightActive();
        return;
      }

      if (e.key === "ArrowUp") {
        e.preventDefault();
        suggestionState.activeIndex = (suggestionState.activeIndex - 1 + max) % max;
        highlightActive();
        return;
      }

      if (e.key === "Enter") {
        if (suggestionState.activeIndex >= 0 && suggestionState.activeIndex < max) {
          e.preventDefault();
          const value = suggestionState.items[suggestionState.activeIndex];
          onPick(value);
        }
        return;
      }

      if (e.key === "Escape") {
        e.preventDefault();
        closeSuggestions();
        return;
      }
    }
function sortShortFirst(arr){
  return (arr || []).slice().sort((a,b) => {
    const la = String(a||"").length;
    const lb = String(b||"").length;
    if (la !== lb) return la - lb;                 // shortest first
    return String(a||"").localeCompare(String(b||"")); // then alphabetical
  });
}
    function buildUnifiedSuggestions(typed){
      if (!dealsSuggest.ready) return { items: [], mode: "model", brand: "" };

      const t = String(typed || "").trim();
      if (!t) return { items: [], mode: "model", brand: "" };

      const { brand, rest } = detectBrandPrefix(t);

// Brand context: suggest "Brand" first, then "Brand Model" shortest→longest
if (brand) {
  const pool = dealsSuggest.brandToModels.has(brand)
    ? Array.from(dealsSuggest.brandToModels.get(brand).values())
    : [];

  // If user only typed the brand (no rest), show:
  // Nike
  // Nike Alphafly
  // Nike Alphafly 2
  // ...
  if (!rest) {
    const modelsShort = sortShortFirst(pool).slice(0, 11); // 11 because brand itself is #1
    return {
      items: [brand, ...modelsShort.map(m => `${brand} ${m}`)],
      mode: "brandmodel",
      brand,
    };
  }

  // If they typed brand + something, rank matches, but prefer shorter on ties
  const matches = filterSuggestions(pool, rest, 12);
  const ordered = sortShortFirst(matches);

  return {
    items: ordered.map(m => `${brand} ${m}`),
    mode: "brandmodel",
    brand,
  };
}


      // No brand context: suggest model-only
      const matches = filterSuggestions(dealsSuggest.allModels, t, 12);
      return { items: matches, mode: "model", brand: "" };
    }

    function splitBrandModelFromPicked(picked){
      const s = String(picked || "").trim();
      if (!s) return { brand: "", model: "" };

      if (!dealsSuggest.ready) ret
